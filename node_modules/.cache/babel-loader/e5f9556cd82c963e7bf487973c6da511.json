{"ast":null,"code":"'use strict';\n\n/**\n * Module dependencies\n */\n/*global setImmediate:true*/\nvar events = require('events'),\n  Store = require('./store'),\n  eos = require('end-of-stream'),\n  mqttPacket = require('mqtt-packet'),\n  Writable = require('readable-stream').Writable,\n  inherits = require('inherits'),\n  reInterval = require('reinterval'),\n  setImmediate = global.setImmediate || function (callback) {\n    // works in node v0.8\n    process.nextTick(callback);\n  },\n  defaultConnectOptions = {\n    keepalive: 10,\n    protocolId: 'MQTT',\n    protocolVersion: 4,\n    reconnectPeriod: 1000,\n    connectTimeout: 30 * 1000,\n    clean: true\n  };\nfunction defaultId() {\n  return 'mqttjs_' + Math.random().toString(16).substr(2, 8);\n}\nfunction sendPacket(client, packet, cb) {\n  try {\n    var buf = mqttPacket.generate(packet);\n    if (!client.stream.write(buf) && cb) {\n      client.stream.once('drain', cb);\n    } else if (cb) {\n      cb();\n    }\n  } catch (err) {\n    if (cb) {\n      cb(err);\n    } else {\n      client.emit('error', err);\n    }\n  }\n}\nfunction storeAndSend(client, packet, cb) {\n  client.outgoingStore.put(packet, function storedPacket(err) {\n    if (err) {\n      return cb && cb(err);\n    }\n    sendPacket(client, packet, cb);\n  });\n}\nfunction nop() {}\n\n/**\n * MqttClient constructor\n *\n * @param {Stream} stream - stream\n * @param {Object} [options] - connection options\n * (see Connection#connect)\n */\nfunction MqttClient(streamBuilder, options) {\n  var k,\n    that = this;\n  if (!(this instanceof MqttClient)) {\n    return new MqttClient(streamBuilder, options);\n  }\n  this.options = options || {};\n\n  // Defaults\n  for (k in defaultConnectOptions) {\n    if ('undefined' === typeof this.options[k]) {\n      this.options[k] = defaultConnectOptions[k];\n    } else {\n      this.options[k] = options[k];\n    }\n  }\n  this.options.clientId = this.options.clientId || defaultId();\n  this.streamBuilder = streamBuilder;\n\n  // Inflight message storages\n  this.outgoingStore = this.options.outgoingStore || new Store();\n  this.incomingStore = this.options.incomingStore || new Store();\n\n  // Ping timer, setup in _setupPingTimer\n  this.pingTimer = null;\n  // Is the client connected?\n  this.connected = false;\n  // Are we disconnecting?\n  this.disconnecting = false;\n  // Packet queue\n  this.queue = [];\n  // connack timer\n  this.connackTimer = null;\n  // Reconnect timer\n  this.reconnectTimer = null;\n  // MessageIDs starting with 1\n  this.nextId = Math.floor(Math.random() * 65535);\n\n  // Inflight callbacks\n  this.outgoing = {};\n\n  // Mark connected on connect\n  this.on('connect', function () {\n    this.connected = true;\n    var outStore = null;\n    outStore = this.outgoingStore.createStream();\n\n    // Control of stored messages\n    outStore.once('readable', function () {\n      function storeDeliver() {\n        var packet = outStore.read(1),\n          cb;\n        if (!packet) {\n          return;\n        }\n        // Avoid unnecesary stream read operations when disconnected\n        if (!that.disconnecting && !that.reconnectTimer && 0 < that.options.reconnectPeriod) {\n          outStore.read(0);\n          cb = that.outgoing[packet.messageId];\n          that.outgoing[packet.messageId] = function () {\n            // Ensure that the original callback passed in to publish gets invoked\n            if (cb) {\n              cb();\n            }\n            // Ensure that the next message will only be read after callback is issued\n            storeDeliver();\n          };\n          that._sendPacket(packet);\n        } else if (outStore.destroy) {\n          outStore.destroy();\n        }\n      }\n      storeDeliver();\n    }).on('error', this.emit.bind(this, 'error'));\n  });\n\n  // Mark disconnected on stream close\n  this.on('close', function () {\n    this.connected = false;\n    clearTimeout(this.connackTimer);\n  });\n\n  // Setup ping timer\n  this.on('connect', this._setupPingTimer);\n\n  // Send queued packets\n  this.on('connect', function () {\n    var queue = this.queue;\n    function deliver() {\n      var entry = queue.shift(),\n        packet = null;\n      if (!entry) {\n        return;\n      }\n      packet = entry.packet;\n      that._sendPacket(packet, function (err) {\n        if (entry.cb) {\n          entry.cb(err);\n        }\n        deliver();\n      });\n    }\n    deliver();\n  });\n\n  // Clear ping timer\n  this.on('close', function () {\n    if (null !== that.pingTimer) {\n      that.pingTimer.clear();\n      that.pingTimer = null;\n    }\n  });\n\n  // Setup reconnect timer on disconnect\n  this.on('close', this._setupReconnect);\n  events.EventEmitter.call(this);\n  this._setupStream();\n}\ninherits(MqttClient, events.EventEmitter);\n\n/**\n * setup the event handlers in the inner stream.\n *\n * @api private\n */\nMqttClient.prototype._setupStream = function () {\n  var connectPacket,\n    that = this,\n    writable = new Writable(),\n    parser = mqttPacket.parser(this.options),\n    completeParse = null,\n    packets = [];\n  this._clearReconnect();\n  this.stream = this.streamBuilder(this);\n  parser.on('packet', function (packet) {\n    packets.push(packet);\n  });\n  function process() {\n    var packet = packets.shift(),\n      done = completeParse;\n    if (packet) {\n      that._handlePacket(packet, process);\n    } else {\n      completeParse = null;\n      done();\n    }\n  }\n  writable._write = function (buf, enc, done) {\n    completeParse = done;\n    parser.parse(buf);\n    process();\n  };\n  this.stream.pipe(writable);\n\n  // Suppress connection errors\n  this.stream.on('error', nop);\n\n  // Echo stream close\n  eos(this.stream, this.emit.bind(this, 'close'));\n\n  // Send a connect packet\n  connectPacket = Object.create(this.options);\n  connectPacket.cmd = 'connect';\n  // avoid message queue\n  sendPacket(this, connectPacket);\n\n  // Echo connection errors\n  parser.on('error', this.emit.bind(this, 'error'));\n\n  // many drain listeners are needed for qos 1 callbacks if the connection is intermittent\n  this.stream.setMaxListeners(1000);\n  clearTimeout(this.connackTimer);\n  this.connackTimer = setTimeout(function () {\n    that._cleanUp(true);\n  }, this.options.connectTimeout);\n};\nMqttClient.prototype._handlePacket = function (packet, done) {\n  switch (packet.cmd) {\n    case 'publish':\n      this._handlePublish(packet, done);\n      break;\n    case 'puback':\n    case 'pubrec':\n    case 'pubcomp':\n    case 'suback':\n    case 'unsuback':\n      this._handleAck(packet);\n      done();\n      break;\n    case 'pubrel':\n      this._handlePubrel(packet, done);\n      break;\n    case 'connack':\n      this._handleConnack(packet);\n      done();\n      break;\n    case 'pingresp':\n      this._handlePingresp(packet);\n      done();\n      break;\n    default:\n      // do nothing\n      // maybe we should do an error handling\n      // or just log it\n      break;\n  }\n};\nMqttClient.prototype._checkDisconnecting = function (callback) {\n  if (this.disconnecting) {\n    if (callback) {\n      callback(new Error('client disconnecting'));\n    } else {\n      this.emit('error', new Error('client disconnecting'));\n    }\n  }\n  return this.disconnecting;\n};\n\n/**\n * publish - publish <message> to <topic>\n *\n * @param {String} topic - topic to publish to\n * @param {String, Buffer} message - message to publish\n * @param {Object} [opts] - publish options, includes:\n *    {Number} qos - qos level to publish on\n *    {Boolean} retain - whether or not to retain the message\n * @param {Function} [callback] - function(err){}\n *    called when publish succeeds or fails\n * @returns {MqttClient} this - for chaining\n * @api public\n *\n * @example client.publish('topic', 'message');\n * @example\n *     client.publish('topic', 'message', {qos: 1, retain: true});\n * @example client.publish('topic', 'message', console.log);\n */\nMqttClient.prototype.publish = function (topic, message, opts, callback) {\n  var packet;\n\n  // .publish(topic, payload, cb);\n  if ('function' === typeof opts) {\n    callback = opts;\n    opts = null;\n  }\n\n  // Default opts\n  if (!opts) {\n    opts = {\n      qos: 0,\n      retain: false\n    };\n  }\n  if (this._checkDisconnecting(callback)) {\n    return this;\n  }\n  packet = {\n    cmd: 'publish',\n    topic: topic,\n    payload: message,\n    qos: opts.qos,\n    retain: opts.retain,\n    messageId: this._nextId()\n  };\n  switch (opts.qos) {\n    case 1:\n    case 2:\n      // Add to callbacks\n      this.outgoing[packet.messageId] = callback || nop;\n      this._sendPacket(packet);\n      break;\n    default:\n      this._sendPacket(packet, callback);\n      break;\n  }\n  return this;\n};\n\n/**\n * subscribe - subscribe to <topic>\n *\n * @param {String, Array, Object} topic - topic(s) to subscribe to, supports objects in the form {'topic': qos}\n * @param {Object} [opts] - optional subscription options, includes:\n *    {Number} qos - subscribe qos level\n * @param {Function} [callback] - function(err, granted){} where:\n *    {Error} err - subscription error (none at the moment!)\n *    {Array} granted - array of {topic: 't', qos: 0}\n * @returns {MqttClient} this - for chaining\n * @api public\n * @example client.subscribe('topic');\n * @example client.subscribe('topic', {qos: 1});\n * @example client.subscribe({'topic': 0, 'topic2': 1}, console.log);\n * @example client.subscribe('topic', console.log);\n */\nMqttClient.prototype.subscribe = function () {\n  var packet,\n    args = Array.prototype.slice.call(arguments),\n    subs = [],\n    obj = args.shift(),\n    callback = args.pop() || nop,\n    opts = args.pop();\n  if ('string' === typeof obj) {\n    obj = [obj];\n  }\n  if ('function' !== typeof callback) {\n    opts = callback;\n    callback = nop;\n  }\n  if (this._checkDisconnecting(callback)) {\n    return this;\n  }\n  if (!opts) {\n    opts = {\n      qos: 0\n    };\n  }\n  if (Array.isArray(obj)) {\n    obj.forEach(function (topic) {\n      subs.push({\n        topic: topic,\n        qos: opts.qos\n      });\n    });\n  } else {\n    Object.keys(obj).forEach(function (k) {\n      subs.push({\n        topic: k,\n        qos: obj[k]\n      });\n    });\n  }\n  packet = {\n    cmd: 'subscribe',\n    subscriptions: subs,\n    qos: 1,\n    retain: false,\n    dup: false,\n    messageId: this._nextId()\n  };\n  this.outgoing[packet.messageId] = callback;\n  this._sendPacket(packet);\n  return this;\n};\n\n/**\n * unsubscribe - unsubscribe from topic(s)\n *\n * @param {String, Array} topic - topics to unsubscribe from\n * @param {Function} [callback] - callback fired on unsuback\n * @returns {MqttClient} this - for chaining\n * @api public\n * @example client.unsubscribe('topic');\n * @example client.unsubscribe('topic', console.log);\n */\nMqttClient.prototype.unsubscribe = function (topic, callback) {\n  var packet = {\n    cmd: 'unsubscribe',\n    qos: 1,\n    messageId: this._nextId()\n  };\n  callback = callback || nop;\n  if (this._checkDisconnecting(callback)) {\n    return this;\n  }\n  if ('string' === typeof topic) {\n    packet.unsubscriptions = [topic];\n  } else if ('object' === typeof topic && topic.length) {\n    packet.unsubscriptions = topic;\n  }\n  this.outgoing[packet.messageId] = callback;\n  this._sendPacket(packet);\n  return this;\n};\n\n/**\n * end - close connection\n *\n * @returns {MqttClient} this - for chaining\n * @param {Boolean} force - do not wait for all in-flight messages to be acked\n * @param {Function} cb - called when the client has been closed\n *\n * @api public\n */\nMqttClient.prototype.end = function (force, cb) {\n  var that = this;\n  if ('function' === typeof force) {\n    cb = force;\n    force = false;\n  }\n  function closeStores() {\n    that.incomingStore.close(function () {\n      that.outgoingStore.close(cb);\n    });\n  }\n  function finish() {\n    that._cleanUp(force, closeStores);\n  }\n  if (this.disconnecting) {\n    return true;\n  }\n  this.disconnecting = true;\n  if (!force && 0 < Object.keys(this.outgoing).length) {\n    // wait 10ms, just to be sure we received all of it\n    this.once('outgoingEmpty', setTimeout.bind(null, finish, 10));\n  } else {\n    finish();\n  }\n  return this;\n};\n\n/**\n * _reconnect - implement reconnection\n * @api privateish\n */\nMqttClient.prototype._reconnect = function () {\n  this.emit('reconnect');\n  this._setupStream();\n};\n\n/**\n * _setupReconnect - setup reconnect timer\n */\nMqttClient.prototype._setupReconnect = function () {\n  var that = this;\n  if (!that.disconnecting && !that.reconnectTimer && 0 < that.options.reconnectPeriod) {\n    this.emit('offline');\n    that.reconnectTimer = setInterval(function () {\n      that._reconnect();\n    }, that.options.reconnectPeriod);\n  }\n};\n\n/**\n * _clearReconnect - clear the reconnect timer\n */\nMqttClient.prototype._clearReconnect = function () {\n  if (this.reconnectTimer) {\n    clearInterval(this.reconnectTimer);\n    this.reconnectTimer = false;\n  }\n};\n\n/**\n * _cleanUp - clean up on connection end\n * @api private\n */\nMqttClient.prototype._cleanUp = function (forced, done) {\n  if (done) {\n    this.stream.on('close', done);\n  }\n  if (forced) {\n    this.stream.destroy();\n  } else {\n    this._sendPacket({\n      cmd: 'disconnect'\n    }, setImmediate.bind(null, this.stream.end.bind(this.stream)));\n  }\n  if (this.reconnectTimer) {\n    this._clearReconnect();\n    this._setupReconnect();\n  }\n  if (null !== this.pingTimer) {\n    this.pingTimer.clear();\n    this.pingTimer = null;\n  }\n};\n\n/**\n * _sendPacket - send or queue a packet\n * @param {String} type - packet type (see `protocol`)\n * @param {Object} packet - packet options\n * @param {Function} cb - callback when the packet is sent\n * @api private\n */\nMqttClient.prototype._sendPacket = function (packet, cb) {\n  if (!this.connected) {\n    return this.queue.push({\n      packet: packet,\n      cb: cb\n    });\n  }\n\n  // When sending a packet, reschedule the ping timer\n  this._shiftPingInterval();\n  switch (packet.qos) {\n    case 2:\n    case 1:\n      storeAndSend(this, packet, cb);\n      break;\n    /**\n     * no need of case here since it will be caught by default\n     * and jshint comply that before default it must be a break\n     * anyway it will result in -1 evaluation\n     */\n    case 0:\n    /* falls through */\n    default:\n      sendPacket(this, packet, cb);\n      break;\n  }\n};\n\n/**\n * _setupPingTimer - setup the ping timer\n *\n * @api private\n */\nMqttClient.prototype._setupPingTimer = function () {\n  var that = this;\n  if (!this.pingTimer && this.options.keepalive) {\n    this.pingResp = true;\n    this.pingTimer = reInterval(function () {\n      that._checkPing();\n    }, this.options.keepalive * 1000);\n  }\n};\n\n/**\n * _shiftPingInterval - reschedule the ping interval\n *\n * @api private\n */\nMqttClient.prototype._shiftPingInterval = function () {\n  if (this.pingTimer && this.options.keepalive) {\n    this.pingTimer.reschedule(this.options.keepalive * 1000);\n  }\n};\n/**\n * _checkPing - check if a pingresp has come back, and ping the server again\n *\n * @api private\n */\nMqttClient.prototype._checkPing = function () {\n  if (this.pingResp) {\n    this.pingResp = false;\n    this._sendPacket({\n      cmd: 'pingreq'\n    });\n  } else {\n    // do a forced cleanup since socket will be in bad shape\n    this._cleanUp(true);\n  }\n};\n\n/**\n * _handlePingresp - handle a pingresp\n *\n * @api private\n */\nMqttClient.prototype._handlePingresp = function () {\n  this.pingResp = true;\n};\n\n/**\n * _handleConnack\n *\n * @param {Object} packet\n * @api private\n */\n\nMqttClient.prototype._handleConnack = function (packet) {\n  var rc = packet.returnCode,\n    // TODO: move to protocol\n    errors = ['', 'Unacceptable protocol version', 'Identifier rejected', 'Server unavailable', 'Bad username or password', 'Not authorized'];\n  clearTimeout(this.connackTimer);\n  if (0 === rc) {\n    this.emit('connect', packet);\n  } else if (0 < rc) {\n    this.emit('error', new Error('Connection refused: ' + errors[rc]));\n  }\n};\n\n/**\n * _handlePublish\n *\n * @param {Object} packet\n * @api private\n */\n/*\nthose late 2 case should be rewrite to comply with coding style:\n\ncase 1:\ncase 0:\n  // do not wait sending a puback\n  // no callback passed\n  if (1 === qos) {\n    this._sendPacket({\n      cmd: 'puback',\n      messageId: mid\n    });\n  }\n  // emit the message event for both qos 1 and 0\n  this.emit('message', topic, message, packet);\n  this.handleMessage(packet, done);\n  break;\ndefault:\n  // do nothing but every switch mus have a default\n  // log or throw an error about unknown qos\n  break;\n\nfor now i just suppressed the warnings\n*/\nMqttClient.prototype._handlePublish = function (packet, done) {\n  var topic = packet.topic.toString(),\n    message = packet.payload,\n    qos = packet.qos,\n    mid = packet.messageId,\n    that = this;\n  switch (qos) {\n    case 2:\n      this.incomingStore.put(packet, function () {\n        that._sendPacket({\n          cmd: 'pubrec',\n          messageId: mid\n        }, done);\n      });\n      break;\n    case 1:\n      // do not wait sending a puback\n      // no callback passed\n      this._sendPacket({\n        cmd: 'puback',\n        messageId: mid\n      });\n    /* falls through */\n    case 0:\n      // emit the message event for both qos 1 and 0\n      this.emit('message', topic, message, packet);\n      this.handleMessage(packet, done);\n      break;\n    default:\n      // do nothing\n      // log or throw an error about unknown qos\n      break;\n  }\n};\n\n/**\n * Handle messages with backpressure support, one at a time.\n * Override at will.\n *\n * @param Packet packet the packet\n * @param Function callback call when finished\n * @api public\n */\nMqttClient.prototype.handleMessage = function (packet, callback) {\n  callback();\n};\n\n/**\n * _handleAck\n *\n * @param {Object} packet\n * @api private\n */\n\nMqttClient.prototype._handleAck = function (packet) {\n  var mid = packet.messageId,\n    type = packet.cmd,\n    response = null,\n    cb = this.outgoing[mid],\n    that = this;\n  if (!cb) {\n    // Server sent an ack in error, ignore it.\n    return;\n  }\n\n  // Process\n  switch (type) {\n    case 'pubcomp':\n    // same thing as puback for QoS 2\n    case 'puback':\n      // Callback - we're done\n      delete this.outgoing[mid];\n      this.outgoingStore.del(packet, cb);\n      break;\n    case 'pubrec':\n      response = {\n        cmd: 'pubrel',\n        qos: 2,\n        messageId: mid\n      };\n      this._sendPacket(response);\n      break;\n    case 'suback':\n      delete this.outgoing[mid];\n      this.outgoingStore.del(packet, function (err, original) {\n        var i,\n          origSubs = original.subscriptions,\n          granted = packet.granted;\n        if (err) {\n          // missing packet, what should we do?\n          return that.emit('error', err);\n        }\n        for (i = 0; i < granted.length; i += 1) {\n          origSubs[i].qos = granted[i];\n        }\n        cb(null, origSubs);\n      });\n      break;\n    case 'unsuback':\n      delete this.outgoing[mid];\n      this.outgoingStore.del(packet, cb);\n      break;\n    default:\n      that.emit('error', new Error('unrecognized packet type'));\n  }\n  if (this.disconnecting && 0 === Object.keys(this.outgoing).length) {\n    this.emit('outgoingEmpty');\n  }\n};\n\n/**\n * _handlePubrel\n *\n * @param {Object} packet\n * @api private\n */\n\nMqttClient.prototype._handlePubrel = function (packet, callback) {\n  var mid = packet.messageId,\n    that = this;\n  that.incomingStore.get(packet, function (err, pub) {\n    if (err) {\n      return that.emit('error', err);\n    }\n    if ('pubrel' !== pub.cmd) {\n      that.emit('message', pub.topic, pub.payload, pub);\n      that.incomingStore.put(packet);\n    }\n    that._sendPacket({\n      cmd: 'pubcomp',\n      messageId: mid\n    }, callback);\n  });\n};\n\n/**\n * _nextId\n */\nMqttClient.prototype._nextId = function () {\n  var id = this.nextId++;\n  // Ensure 16 bit unsigned int:\n  if (65535 === id) {\n    this.nextId = 1;\n  }\n  return id;\n};\nmodule.exports = MqttClient;","map":{"version":3,"names":["events","require","Store","eos","mqttPacket","Writable","inherits","reInterval","setImmediate","global","callback","process","nextTick","defaultConnectOptions","keepalive","protocolId","protocolVersion","reconnectPeriod","connectTimeout","clean","defaultId","Math","random","toString","substr","sendPacket","client","packet","cb","buf","generate","stream","write","once","err","emit","storeAndSend","outgoingStore","put","storedPacket","nop","MqttClient","streamBuilder","options","k","that","clientId","incomingStore","pingTimer","connected","disconnecting","queue","connackTimer","reconnectTimer","nextId","floor","outgoing","on","outStore","createStream","storeDeliver","read","messageId","_sendPacket","destroy","bind","clearTimeout","_setupPingTimer","deliver","entry","shift","clear","_setupReconnect","EventEmitter","call","_setupStream","prototype","connectPacket","writable","parser","completeParse","packets","_clearReconnect","push","done","_handlePacket","_write","enc","parse","pipe","Object","create","cmd","setMaxListeners","setTimeout","_cleanUp","_handlePublish","_handleAck","_handlePubrel","_handleConnack","_handlePingresp","_checkDisconnecting","Error","publish","topic","message","opts","qos","retain","payload","_nextId","subscribe","args","Array","slice","arguments","subs","obj","pop","isArray","forEach","keys","subscriptions","dup","unsubscribe","unsubscriptions","length","end","force","closeStores","close","finish","_reconnect","setInterval","clearInterval","forced","_shiftPingInterval","pingResp","_checkPing","reschedule","rc","returnCode","errors","mid","handleMessage","type","response","del","original","i","origSubs","granted","get","pub","id","module","exports"],"sources":["D:/UFPB/aquisição/hb/aquisicao/node_modules/mqtt-client/lib/client.js"],"sourcesContent":["'use strict';\n/**\n * Module dependencies\n */\n/*global setImmediate:true*/\nvar events = require('events'),\n  Store = require('./store'),\n  eos = require('end-of-stream'),\n  mqttPacket = require('mqtt-packet'),\n  Writable = require('readable-stream').Writable,\n  inherits = require('inherits'),\n  reInterval = require('reinterval'),\n  setImmediate = global.setImmediate || function (callback) {\n    // works in node v0.8\n    process.nextTick(callback);\n  },\n  defaultConnectOptions = {\n    keepalive: 10,\n    protocolId: 'MQTT',\n    protocolVersion: 4,\n    reconnectPeriod: 1000,\n    connectTimeout: 30 * 1000,\n    clean: true\n  };\n\nfunction defaultId () {\n  return 'mqttjs_' + Math.random().toString(16).substr(2, 8);\n}\n\nfunction sendPacket (client, packet, cb) {\n  try {\n    var buf = mqttPacket.generate(packet);\n    if (!client.stream.write(buf) && cb) {\n      client.stream.once('drain', cb);\n    } else if (cb) {\n      cb();\n    }\n  } catch (err) {\n    if (cb) {\n      cb(err);\n    } else {\n      client.emit('error', err);\n    }\n  }\n}\n\nfunction storeAndSend (client, packet, cb) {\n  client.outgoingStore.put(packet, function storedPacket (err) {\n    if (err) {\n      return cb && cb(err);\n    }\n    sendPacket(client, packet, cb);\n  });\n}\n\nfunction nop () {}\n\n/**\n * MqttClient constructor\n *\n * @param {Stream} stream - stream\n * @param {Object} [options] - connection options\n * (see Connection#connect)\n */\nfunction MqttClient (streamBuilder, options) {\n  var k,\n    that = this;\n\n  if (!(this instanceof MqttClient)) {\n    return new MqttClient(streamBuilder, options);\n  }\n\n  this.options = options || {};\n\n  // Defaults\n  for (k in defaultConnectOptions) {\n    if ('undefined' === typeof this.options[k]) {\n      this.options[k] = defaultConnectOptions[k];\n    } else {\n      this.options[k] = options[k];\n    }\n  }\n\n  this.options.clientId = this.options.clientId || defaultId();\n\n  this.streamBuilder = streamBuilder;\n\n  // Inflight message storages\n  this.outgoingStore = this.options.outgoingStore || new Store();\n  this.incomingStore = this.options.incomingStore || new Store();\n\n  // Ping timer, setup in _setupPingTimer\n  this.pingTimer = null;\n  // Is the client connected?\n  this.connected = false;\n  // Are we disconnecting?\n  this.disconnecting = false;\n  // Packet queue\n  this.queue = [];\n  // connack timer\n  this.connackTimer = null;\n  // Reconnect timer\n  this.reconnectTimer = null;\n  // MessageIDs starting with 1\n  this.nextId = Math.floor(Math.random() * 65535);\n\n  // Inflight callbacks\n  this.outgoing = {};\n\n  // Mark connected on connect\n  this.on('connect', function () {\n    this.connected = true;\n    var outStore = null;\n    outStore = this.outgoingStore.createStream();\n\n    // Control of stored messages\n    outStore.once('readable', function () {\n      function storeDeliver () {\n        var packet = outStore.read(1),\n          cb;\n        if (!packet) {\n          return;\n        }\n        // Avoid unnecesary stream read operations when disconnected\n        if (!that.disconnecting && !that.reconnectTimer && (0 < that.options.reconnectPeriod)) {\n          outStore.read(0);\n          cb = that.outgoing[packet.messageId];\n          that.outgoing[packet.messageId] = function () {\n            // Ensure that the original callback passed in to publish gets invoked\n            if (cb) {\n              cb();\n            }\n            // Ensure that the next message will only be read after callback is issued\n            storeDeliver();\n          };\n          that._sendPacket(packet);\n        } else if (outStore.destroy) {\n          outStore.destroy();\n        }\n      }\n      storeDeliver();\n    })\n    .on('error', this.emit.bind(this, 'error'));\n  });\n\n  // Mark disconnected on stream close\n  this.on('close', function () {\n    this.connected = false;\n    clearTimeout(this.connackTimer);\n  });\n\n  // Setup ping timer\n  this.on('connect', this._setupPingTimer);\n\n  // Send queued packets\n  this.on('connect', function () {\n    var queue = this.queue;\n\n    function deliver () {\n      var entry = queue.shift(),\n        packet = null;\n\n      if (!entry) {\n        return;\n      }\n\n      packet = entry.packet;\n\n      that._sendPacket(\n        packet,\n        function (err) {\n          if (entry.cb) {\n            entry.cb(err);\n          }\n          deliver();\n        }\n      );\n    }\n\n    deliver();\n  });\n\n\n  // Clear ping timer\n  this.on('close', function () {\n    if (null !== that.pingTimer) {\n      that.pingTimer.clear();\n      that.pingTimer = null;\n    }\n  });\n\n  // Setup reconnect timer on disconnect\n  this.on('close', this._setupReconnect);\n\n  events.EventEmitter.call(this);\n\n  this._setupStream();\n}\ninherits(MqttClient, events.EventEmitter);\n\n/**\n * setup the event handlers in the inner stream.\n *\n * @api private\n */\nMqttClient.prototype._setupStream = function () {\n  var connectPacket,\n    that = this,\n    writable = new Writable(),\n    parser = mqttPacket.parser(this.options),\n    completeParse = null,\n    packets = [];\n\n  this._clearReconnect();\n\n  this.stream = this.streamBuilder(this);\n\n  parser.on('packet', function (packet) {\n    packets.push(packet);\n  });\n\n  function process () {\n    var packet = packets.shift(),\n      done = completeParse;\n    if (packet) {\n      that._handlePacket(packet, process);\n    } else {\n      completeParse = null;\n      done();\n    }\n  }\n\n  writable._write = function (buf, enc, done) {\n    completeParse = done;\n    parser.parse(buf);\n    process();\n  };\n\n  this.stream.pipe(writable);\n\n  // Suppress connection errors\n  this.stream.on('error', nop);\n\n  // Echo stream close\n  eos(this.stream, this.emit.bind(this, 'close'));\n\n  // Send a connect packet\n  connectPacket = Object.create(this.options);\n  connectPacket.cmd = 'connect';\n  // avoid message queue\n  sendPacket(this, connectPacket);\n\n  // Echo connection errors\n  parser.on('error', this.emit.bind(this, 'error'));\n\n  // many drain listeners are needed for qos 1 callbacks if the connection is intermittent\n  this.stream.setMaxListeners(1000);\n\n  clearTimeout(this.connackTimer);\n  this.connackTimer = setTimeout(function () {\n    that._cleanUp(true);\n  }, this.options.connectTimeout);\n};\n\nMqttClient.prototype._handlePacket = function (packet, done) {\n  switch (packet.cmd) {\n    case 'publish':\n      this._handlePublish(packet, done);\n      break;\n    case 'puback':\n    case 'pubrec':\n    case 'pubcomp':\n    case 'suback':\n    case 'unsuback':\n      this._handleAck(packet);\n      done();\n      break;\n    case 'pubrel':\n      this._handlePubrel(packet, done);\n      break;\n    case 'connack':\n      this._handleConnack(packet);\n      done();\n      break;\n    case 'pingresp':\n      this._handlePingresp(packet);\n      done();\n      break;\n    default:\n      // do nothing\n      // maybe we should do an error handling\n      // or just log it\n      break;\n  }\n};\n\nMqttClient.prototype._checkDisconnecting = function (callback) {\n  if (this.disconnecting) {\n    if (callback) {\n      callback(new Error('client disconnecting'));\n    } else {\n      this.emit('error', new Error('client disconnecting'));\n    }\n  }\n  return this.disconnecting;\n};\n\n/**\n * publish - publish <message> to <topic>\n *\n * @param {String} topic - topic to publish to\n * @param {String, Buffer} message - message to publish\n * @param {Object} [opts] - publish options, includes:\n *    {Number} qos - qos level to publish on\n *    {Boolean} retain - whether or not to retain the message\n * @param {Function} [callback] - function(err){}\n *    called when publish succeeds or fails\n * @returns {MqttClient} this - for chaining\n * @api public\n *\n * @example client.publish('topic', 'message');\n * @example\n *     client.publish('topic', 'message', {qos: 1, retain: true});\n * @example client.publish('topic', 'message', console.log);\n */\nMqttClient.prototype.publish = function (topic, message, opts, callback) {\n  var packet;\n\n  // .publish(topic, payload, cb);\n  if ('function' === typeof opts) {\n    callback = opts;\n    opts = null;\n  }\n\n  // Default opts\n  if (!opts) {\n    opts = {qos: 0, retain: false};\n  }\n\n  if (this._checkDisconnecting(callback)) {\n    return this;\n  }\n\n  packet = {\n    cmd: 'publish',\n    topic: topic,\n    payload: message,\n    qos: opts.qos,\n    retain: opts.retain,\n    messageId: this._nextId()\n  };\n\n  switch (opts.qos) {\n    case 1:\n    case 2:\n\n      // Add to callbacks\n      this.outgoing[packet.messageId] = callback || nop;\n      this._sendPacket(packet);\n      break;\n    default:\n      this._sendPacket(packet, callback);\n      break;\n  }\n\n  return this;\n};\n\n/**\n * subscribe - subscribe to <topic>\n *\n * @param {String, Array, Object} topic - topic(s) to subscribe to, supports objects in the form {'topic': qos}\n * @param {Object} [opts] - optional subscription options, includes:\n *    {Number} qos - subscribe qos level\n * @param {Function} [callback] - function(err, granted){} where:\n *    {Error} err - subscription error (none at the moment!)\n *    {Array} granted - array of {topic: 't', qos: 0}\n * @returns {MqttClient} this - for chaining\n * @api public\n * @example client.subscribe('topic');\n * @example client.subscribe('topic', {qos: 1});\n * @example client.subscribe({'topic': 0, 'topic2': 1}, console.log);\n * @example client.subscribe('topic', console.log);\n */\nMqttClient.prototype.subscribe = function () {\n  var packet,\n    args = Array.prototype.slice.call(arguments),\n    subs = [],\n    obj = args.shift(),\n    callback = args.pop() || nop,\n    opts = args.pop();\n\n  if ('string' === typeof obj) {\n    obj = [obj];\n  }\n\n  if ('function' !== typeof callback) {\n    opts = callback;\n    callback = nop;\n  }\n\n  if (this._checkDisconnecting(callback)) {\n    return this;\n  }\n\n  if (!opts) {\n    opts = { qos: 0 };\n  }\n\n  if (Array.isArray(obj)) {\n    obj.forEach(function (topic) {\n      subs.push({\n        topic: topic,\n        qos: opts.qos\n      });\n    });\n  } else {\n    Object\n      .keys(obj)\n      .forEach(function (k) {\n        subs.push({\n          topic: k,\n          qos: obj[k]\n        });\n      });\n  }\n\n  packet = {\n    cmd: 'subscribe',\n    subscriptions: subs,\n    qos: 1,\n    retain: false,\n    dup: false,\n    messageId: this._nextId()\n  };\n\n  this.outgoing[packet.messageId] = callback;\n\n  this._sendPacket(packet);\n\n  return this;\n};\n\n/**\n * unsubscribe - unsubscribe from topic(s)\n *\n * @param {String, Array} topic - topics to unsubscribe from\n * @param {Function} [callback] - callback fired on unsuback\n * @returns {MqttClient} this - for chaining\n * @api public\n * @example client.unsubscribe('topic');\n * @example client.unsubscribe('topic', console.log);\n */\nMqttClient.prototype.unsubscribe = function (topic, callback) {\n  var packet = {\n    cmd: 'unsubscribe',\n    qos: 1,\n    messageId: this._nextId()\n  };\n\n  callback = callback || nop;\n\n  if (this._checkDisconnecting(callback)) {\n    return this;\n  }\n\n  if ('string' === typeof topic) {\n    packet.unsubscriptions = [topic];\n  } else if ('object' === typeof topic && topic.length) {\n    packet.unsubscriptions = topic;\n  }\n\n  this.outgoing[packet.messageId] = callback;\n\n  this._sendPacket(packet);\n\n  return this;\n};\n\n/**\n * end - close connection\n *\n * @returns {MqttClient} this - for chaining\n * @param {Boolean} force - do not wait for all in-flight messages to be acked\n * @param {Function} cb - called when the client has been closed\n *\n * @api public\n */\nMqttClient.prototype.end = function (force, cb) {\n  var that = this;\n\n  if ('function' === typeof force) {\n    cb = force;\n    force = false;\n  }\n\n  function closeStores () {\n    that.incomingStore.close(function () {\n      that.outgoingStore.close(cb);\n    });\n  }\n\n  function finish () {\n    that._cleanUp(force, closeStores);\n  }\n\n  if (this.disconnecting) {\n    return true;\n  }\n\n  this.disconnecting = true;\n\n  if (!force && 0 < Object.keys(this.outgoing).length) {\n    // wait 10ms, just to be sure we received all of it\n    this.once('outgoingEmpty', setTimeout.bind(null, finish, 10));\n  } else {\n    finish();\n  }\n\n  return this;\n};\n\n/**\n * _reconnect - implement reconnection\n * @api privateish\n */\nMqttClient.prototype._reconnect = function () {\n  this.emit('reconnect');\n  this._setupStream();\n};\n\n/**\n * _setupReconnect - setup reconnect timer\n */\nMqttClient.prototype._setupReconnect = function () {\n  var that = this;\n\n  if (!that.disconnecting && !that.reconnectTimer && (0 < that.options.reconnectPeriod)) {\n    this.emit('offline');\n    that.reconnectTimer = setInterval(function () {\n      that._reconnect();\n    }, that.options.reconnectPeriod);\n  }\n};\n\n/**\n * _clearReconnect - clear the reconnect timer\n */\nMqttClient.prototype._clearReconnect = function () {\n  if (this.reconnectTimer) {\n    clearInterval(this.reconnectTimer);\n    this.reconnectTimer = false;\n  }\n};\n\n\n/**\n * _cleanUp - clean up on connection end\n * @api private\n */\nMqttClient.prototype._cleanUp = function (forced, done) {\n\n  if (done) {\n    this.stream.on('close', done);\n  }\n\n  if (forced) {\n    this.stream.destroy();\n  } else {\n    this._sendPacket(\n      { cmd: 'disconnect' },\n      setImmediate.bind(\n        null,\n        this.stream.end.bind(this.stream)\n      )\n    );\n  }\n\n  if (this.reconnectTimer) {\n    this._clearReconnect();\n    this._setupReconnect();\n  }\n\n  if (null !== this.pingTimer) {\n    this.pingTimer.clear();\n    this.pingTimer = null;\n  }\n};\n\n/**\n * _sendPacket - send or queue a packet\n * @param {String} type - packet type (see `protocol`)\n * @param {Object} packet - packet options\n * @param {Function} cb - callback when the packet is sent\n * @api private\n */\nMqttClient.prototype._sendPacket = function (packet, cb) {\n  if (!this.connected) {\n    return this.queue.push({ packet: packet, cb: cb });\n  }\n\n  // When sending a packet, reschedule the ping timer\n  this._shiftPingInterval();\n\n  switch (packet.qos) {\n    case 2:\n    case 1:\n      storeAndSend(this, packet, cb);\n      break;\n    /**\n     * no need of case here since it will be caught by default\n     * and jshint comply that before default it must be a break\n     * anyway it will result in -1 evaluation\n     */\n    case 0:\n      /* falls through */\n    default:\n      sendPacket(this, packet, cb);\n      break;\n  }\n};\n\n/**\n * _setupPingTimer - setup the ping timer\n *\n * @api private\n */\nMqttClient.prototype._setupPingTimer = function () {\n  var that = this;\n\n  if (!this.pingTimer && this.options.keepalive) {\n    this.pingResp = true;\n    this.pingTimer = reInterval(function () {\n      that._checkPing();\n    }, this.options.keepalive * 1000);\n  }\n};\n\n/**\n * _shiftPingInterval - reschedule the ping interval\n *\n * @api private\n */\nMqttClient.prototype._shiftPingInterval = function () {\n  if (this.pingTimer && this.options.keepalive) {\n    this.pingTimer.reschedule(this.options.keepalive * 1000);\n  }\n};\n/**\n * _checkPing - check if a pingresp has come back, and ping the server again\n *\n * @api private\n */\nMqttClient.prototype._checkPing = function () {\n  if (this.pingResp) {\n    this.pingResp = false;\n    this._sendPacket({ cmd: 'pingreq' });\n  } else {\n    // do a forced cleanup since socket will be in bad shape\n    this._cleanUp(true);\n  }\n};\n\n/**\n * _handlePingresp - handle a pingresp\n *\n * @api private\n */\nMqttClient.prototype._handlePingresp = function () {\n  this.pingResp = true;\n};\n\n/**\n * _handleConnack\n *\n * @param {Object} packet\n * @api private\n */\n\nMqttClient.prototype._handleConnack = function (packet) {\n  var rc = packet.returnCode,\n    // TODO: move to protocol\n    errors = [\n      '',\n      'Unacceptable protocol version',\n      'Identifier rejected',\n      'Server unavailable',\n      'Bad username or password',\n      'Not authorized'\n    ];\n\n  clearTimeout(this.connackTimer);\n\n  if (0 === rc) {\n    this.emit('connect', packet);\n  } else if (0 < rc) {\n    this.emit('error',\n        new Error('Connection refused: ' + errors[rc]));\n  }\n};\n\n/**\n * _handlePublish\n *\n * @param {Object} packet\n * @api private\n */\n/*\nthose late 2 case should be rewrite to comply with coding style:\n\ncase 1:\ncase 0:\n  // do not wait sending a puback\n  // no callback passed\n  if (1 === qos) {\n    this._sendPacket({\n      cmd: 'puback',\n      messageId: mid\n    });\n  }\n  // emit the message event for both qos 1 and 0\n  this.emit('message', topic, message, packet);\n  this.handleMessage(packet, done);\n  break;\ndefault:\n  // do nothing but every switch mus have a default\n  // log or throw an error about unknown qos\n  break;\n\nfor now i just suppressed the warnings\n*/\nMqttClient.prototype._handlePublish = function (packet, done) {\n  var topic = packet.topic.toString(),\n    message = packet.payload,\n    qos = packet.qos,\n    mid = packet.messageId,\n    that = this;\n\n  switch (qos) {\n    case 2:\n      this.incomingStore.put(packet, function () {\n        that._sendPacket({cmd: 'pubrec', messageId: mid}, done);\n      });\n      break;\n    case 1:\n      // do not wait sending a puback\n      // no callback passed\n      this._sendPacket({\n        cmd: 'puback',\n        messageId: mid\n      });\n      /* falls through */\n    case 0:\n      // emit the message event for both qos 1 and 0\n      this.emit('message', topic, message, packet);\n      this.handleMessage(packet, done);\n      break;\n    default:\n      // do nothing\n      // log or throw an error about unknown qos\n      break;\n  }\n};\n\n/**\n * Handle messages with backpressure support, one at a time.\n * Override at will.\n *\n * @param Packet packet the packet\n * @param Function callback call when finished\n * @api public\n */\nMqttClient.prototype.handleMessage = function (packet, callback) {\n  callback();\n};\n\n/**\n * _handleAck\n *\n * @param {Object} packet\n * @api private\n */\n\nMqttClient.prototype._handleAck = function (packet) {\n  var mid = packet.messageId,\n    type = packet.cmd,\n    response = null,\n    cb = this.outgoing[mid],\n    that = this;\n\n  if (!cb) {\n    // Server sent an ack in error, ignore it.\n    return;\n  }\n\n  // Process\n  switch (type) {\n    case 'pubcomp':\n      // same thing as puback for QoS 2\n    case 'puback':\n      // Callback - we're done\n      delete this.outgoing[mid];\n      this.outgoingStore.del(packet, cb);\n      break;\n    case 'pubrec':\n      response = {\n        cmd: 'pubrel',\n        qos: 2,\n        messageId: mid\n      };\n\n      this._sendPacket(response);\n      break;\n    case 'suback':\n      delete this.outgoing[mid];\n      this.outgoingStore.del(packet, function (err, original) {\n        var i,\n          origSubs = original.subscriptions,\n          granted = packet.granted;\n\n        if (err) {\n          // missing packet, what should we do?\n          return that.emit('error', err);\n        }\n\n        for (i = 0; i < granted.length; i += 1) {\n          origSubs[i].qos = granted[i];\n        }\n\n        cb(null, origSubs);\n      });\n      break;\n    case 'unsuback':\n      delete this.outgoing[mid];\n      this.outgoingStore.del(packet, cb);\n      break;\n    default:\n      that.emit('error', new Error('unrecognized packet type'));\n  }\n\n  if (this.disconnecting &&\n      0 === Object.keys(this.outgoing).length) {\n    this.emit('outgoingEmpty');\n  }\n};\n\n/**\n * _handlePubrel\n *\n * @param {Object} packet\n * @api private\n */\n\nMqttClient.prototype._handlePubrel = function (packet, callback) {\n  var mid = packet.messageId,\n    that = this;\n\n  that.incomingStore.get(packet, function (err, pub) {\n    if (err) {\n      return that.emit('error', err);\n    }\n\n    if ('pubrel' !== pub.cmd) {\n      that.emit('message', pub.topic, pub.payload, pub);\n      that.incomingStore.put(packet);\n    }\n\n    that._sendPacket({cmd: 'pubcomp', messageId: mid}, callback);\n  });\n};\n\n/**\n * _nextId\n */\nMqttClient.prototype._nextId = function () {\n  var id = this.nextId++;\n  // Ensure 16 bit unsigned int:\n  if (65535 === id) {\n    this.nextId = 1;\n  }\n  return id;\n};\n\nmodule.exports = MqttClient;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}