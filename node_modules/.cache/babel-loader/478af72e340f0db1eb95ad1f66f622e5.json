{"ast":null,"code":"'use strict';\n\nvar through = require('through2');\nvar duplexify = require('duplexify');\nvar WS = require('ws');\nmodule.exports = WebSocketStream;\nfunction WebSocketStream(target, protocols, options) {\n  var stream, socket;\n  var isBrowser = process.title === 'browser';\n  var isNative = !!global.WebSocket;\n  var socketWrite = isBrowser ? socketWriteBrowser : socketWriteNode;\n  var proxy = through.obj(socketWrite, socketEnd);\n  if (protocols && !Array.isArray(protocols) && 'object' === typeof protocols) {\n    // accept the \"options\" Object as the 2nd argument\n    options = protocols;\n    protocols = null;\n    if (typeof options.protocol === 'string' || Array.isArray(options.protocol)) {\n      protocols = options.protocol;\n    }\n  }\n  if (!options) options = {};\n\n  // browser only: sets the maximum socket buffer size before throttling\n  var bufferSize = options.browserBufferSize || 1024 * 512;\n\n  // browser only: how long to wait when throttling\n  var bufferTimeout = options.browserBufferTimeout || 1000;\n\n  // use existing WebSocket object that was passed in\n  if (typeof target === 'object') {\n    socket = target;\n    // otherwise make a new one\n  } else {\n    // special constructor treatment for native websockets in browsers, see\n    // https://github.com/maxogden/websocket-stream/issues/82\n    if (isNative && isBrowser) {\n      socket = new WS(target, protocols);\n    } else {\n      socket = new WS(target, protocols, options);\n    }\n    socket.binaryType = 'arraybuffer';\n  }\n\n  // was already open when passed in\n  if (socket.readyState === WS.OPEN) {\n    stream = proxy;\n  } else {\n    stream = duplexify.obj();\n    socket.onopen = onopen;\n  }\n  stream.socket = socket;\n  socket.onclose = onclose;\n  socket.onerror = onerror;\n  socket.onmessage = onmessage;\n  proxy.on('close', destroy);\n  var coerceToBuffer = options.binary || options.binary === undefined;\n  function socketWriteNode(chunk, enc, next) {\n    if (coerceToBuffer && typeof chunk === 'string') {\n      chunk = new Buffer(chunk, 'utf8');\n    }\n    socket.send(chunk, next);\n  }\n  function socketWriteBrowser(chunk, enc, next) {\n    if (socket.bufferedAmount > bufferSize) {\n      setTimeout(socketWriteBrowser, bufferTimeout, chunk, enc, next);\n      return;\n    }\n    if (coerceToBuffer && typeof chunk === 'string') {\n      chunk = new Buffer(chunk, 'utf8');\n    }\n    try {\n      socket.send(chunk);\n    } catch (err) {\n      return next(err);\n    }\n    next();\n  }\n  function socketEnd(done) {\n    socket.close();\n    done();\n  }\n  function onopen() {\n    stream.setReadable(proxy);\n    stream.setWritable(proxy);\n    stream.emit('connect');\n  }\n  function onclose() {\n    stream.end();\n    stream.destroy();\n  }\n  function onerror(err) {\n    stream.destroy(err);\n  }\n  function onmessage(event) {\n    var data = event.data;\n    if (data instanceof ArrayBuffer) data = new Buffer(new Uint8Array(data));else data = new Buffer(data);\n    proxy.push(data);\n  }\n  function destroy() {\n    socket.close();\n  }\n  return stream;\n}","map":{"version":3,"names":["through","require","duplexify","WS","module","exports","WebSocketStream","target","protocols","options","stream","socket","isBrowser","process","title","isNative","global","WebSocket","socketWrite","socketWriteBrowser","socketWriteNode","proxy","obj","socketEnd","Array","isArray","protocol","bufferSize","browserBufferSize","bufferTimeout","browserBufferTimeout","binaryType","readyState","OPEN","onopen","onclose","onerror","onmessage","on","destroy","coerceToBuffer","binary","undefined","chunk","enc","next","Buffer","send","bufferedAmount","setTimeout","err","done","close","setReadable","setWritable","emit","end","event","data","ArrayBuffer","Uint8Array","push"],"sources":["D:/UFPB/aquisição/hb/aquisicao/node_modules/websocket-stream/stream.js"],"sourcesContent":["'use strict'\n\nvar through = require('through2')\nvar duplexify = require('duplexify')\nvar WS = require('ws')\n\nmodule.exports = WebSocketStream\n\nfunction WebSocketStream(target, protocols, options) {\n  var stream, socket\n\n  var isBrowser = process.title === 'browser'\n  var isNative = !!global.WebSocket\n  var socketWrite = isBrowser ? socketWriteBrowser : socketWriteNode\n  var proxy = through.obj(socketWrite, socketEnd)\n\n  if (protocols && !Array.isArray(protocols) && 'object' === typeof protocols) {\n    // accept the \"options\" Object as the 2nd argument\n    options = protocols\n    protocols = null\n\n    if (typeof options.protocol === 'string' || Array.isArray(options.protocol)) {\n      protocols = options.protocol;\n    }\n  }\n\n  if (!options) options = {}\n\n  // browser only: sets the maximum socket buffer size before throttling\n  var bufferSize = options.browserBufferSize || 1024 * 512\n\n  // browser only: how long to wait when throttling\n  var bufferTimeout = options.browserBufferTimeout || 1000\n\n  // use existing WebSocket object that was passed in\n  if (typeof target === 'object') {\n    socket = target\n  // otherwise make a new one\n  } else {\n    // special constructor treatment for native websockets in browsers, see\n    // https://github.com/maxogden/websocket-stream/issues/82\n    if (isNative && isBrowser) {\n      socket = new WS(target, protocols)\n    } else {\n      socket = new WS(target, protocols, options)\n    }\n\n    socket.binaryType = 'arraybuffer'\n  }\n\n  // was already open when passed in\n  if (socket.readyState === WS.OPEN) {\n    stream = proxy\n  } else {\n    stream = duplexify.obj()\n    socket.onopen = onopen\n  }\n\n  stream.socket = socket\n\n  socket.onclose = onclose\n  socket.onerror = onerror\n  socket.onmessage = onmessage\n\n  proxy.on('close', destroy)\n\n  var coerceToBuffer = options.binary || options.binary === undefined\n\n  function socketWriteNode(chunk, enc, next) {\n    if (coerceToBuffer && typeof chunk === 'string') {\n      chunk = new Buffer(chunk, 'utf8')\n    }\n    socket.send(chunk, next)\n  }\n\n  function socketWriteBrowser(chunk, enc, next) {\n    if (socket.bufferedAmount > bufferSize) {\n      setTimeout(socketWriteBrowser, bufferTimeout, chunk, enc, next)\n      return\n    }\n\n    if (coerceToBuffer && typeof chunk === 'string') {\n      chunk = new Buffer(chunk, 'utf8')\n    }\n\n    try {\n      socket.send(chunk)\n    } catch(err) {\n      return next(err)\n    }\n\n    next()\n  }\n\n  function socketEnd(done) {\n    socket.close()\n    done()\n  }\n\n  function onopen() {\n    stream.setReadable(proxy)\n    stream.setWritable(proxy)\n    stream.emit('connect')\n  }\n\n  function onclose() {\n    stream.end()\n    stream.destroy()\n  }\n\n  function onerror(err) {\n    stream.destroy(err)\n  }\n\n  function onmessage(event) {\n    var data = event.data\n    if (data instanceof ArrayBuffer) data = new Buffer(new Uint8Array(data))\n    else data = new Buffer(data)\n    proxy.push(data)\n  }\n\n  function destroy() {\n    socket.close()\n  }\n\n  return stream\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}